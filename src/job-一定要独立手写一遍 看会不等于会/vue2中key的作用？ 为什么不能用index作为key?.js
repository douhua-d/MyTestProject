// vue2中key的作用？ 为什么不能用index作为key?


/**
 * <template>
 *   <ul>
 *     <li v-for="(item, index) in items" :key="index">{{ item }}</li>
 *   </ul>
 * </template>
 *
 * <script>
 * export default {
 *   data() {
 *     return {
 *       items: ['A', 'B', 'C', 'D']
 *     };
 *   },
 *   methods: {
 *     removeFirstItem() {
 *       this.items.splice(0, 1);
 *     }
 *   }
 * };
 * </script>
 * 
 * 以上删除第一个 ，会导致不必要的元素新建，不会复用，全都依次变了，因为
 * 
 * Diff 算法的工作原理
 * Vue 的 diff 算法会比较新旧虚拟 DOM 树，找到差异，并进行最小量的 DOM 操作。由于 key 是唯一且稳定的标识，Vue 可以准确地识别哪些节点需要保留，哪些需要删除或新建。
 *
 * 找到相同 key 的节点：Vue 会找到新旧虚拟 DOM 中相同 key 的节点。例如，key="2"、key="3"、key="4" 的节点依然存在。
 * 复用节点：对于相同 key 的节点，Vue 会复用这些节点，并更新其内容（如果需要）。例如，key="2" 对应的 <li> 标签会复用原来的节点，而不是新建。
 * 删除多余节点：Vue 会删除 key="1" 对应的节点，因为在新虚拟 DOM 中不存在这个节点。
 * 新建节点：如果新虚拟 DOM 中存在旧虚拟 DOM 中不存在的 key，Vue 会新建这些节点。
 * 实际操作
 * 对于上述示例，当删除第一个元素时，实际的 DOM 操作如下：
 *
 * 删除 key="1" 的 <li> 标签。
 * 复用 key="2"、key="3"、key="4" 的 <li> 标签，只需更新其位置。
 * 因此，key="2" 的 <li> 标签会从第二个位置移动到第一个位置，而不是新建。
 */

// 如果用唯一的key，就会复用元素，
// 当使用唯一的 key 时，在数组前面新增一个元素，Vue 的 diff 算法会识别出新旧虚拟 DOM 之间的变化。
// 具体来说，它会在前面新增一个元素，并将其余元素按顺序向后移动。
// 但关键点是 Vue 会尽可能复用现有的 DOM 元素，而不是重新创建。


// 用 index 作为 key 时，在对数据进行，逆序添加，逆序删除等破坏顺序的操作时，会产生没必要的真实 DOM更新，从而导致效率低
// 用 index 作为 key 时，如果结构中包含输入类的 DOM，会产生错误的 DOM 更新
// 在开发中最好每条数据使用唯一标识固定的数据作为 key，比如后台返回的 ID，手机号，身份证号等唯一值
// 如果不对数据进行逆序添加 逆序删除破坏顺序的操作， 只用于列表展示的话 使用index 作为Key没有毛病


// 虚拟DMO的 diff 算法 
// diff算法采用同级比较。
// 
//         1、tag 标签不一致直接新节点替换旧节点。
// 
//         2、tag 标签一样。
// 
//                 先替换属性
// 
//                 对比子元素
// 
//                 1.新老都有子元素，采用双指针方式进行对比
// 
//                 sameVnode 判断tag和key完全相同为同一节点，进行节点复用
// 
//                              头和头相等对比
// 
//                              尾和尾相等对比
// 
//                              头和尾相等对比
// 
//                              sameVnode 的时候传入两个新老子节点patch(oldChild,newChild)
// 
//                 乱序情况 -- 上面的都不符合，先遍历旧子节点数组形成 key值映射的map对象。
// 
//                 然后根据新子节点数组循环 按照key值和位置关系移动以及新增节点 最后删除多余的旧子节点 如果移动旧节点同样需要patch(oldChild,newChild)
// 
//                 2.新的有子元素，老的没有子元素。-- 直接将子元素虚拟节点转化成真实节点插入即可。
// 
//                 3.新的没有子元素，老的有子元素。 -- 直接清空 innerHtml
// 
// 3、无 tag 标签 -- 文本节点直接比较内容是否一致



// 为什么要用key?
//在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。
// 
// 同一个父元素下的子元素必须具有唯一的 key。重复的 key 将会导致渲染异常。

// https://blog.csdn.net/qq_39998026/article/details/126656058
//

/**
 * 例如：有元素 A B C D E ,当我想把元素变成 B C D E 时
 *
 * 没有key值时，key默认都是undefined，就会按照diff算法的就地复用来进行比较，它会把A更新成B，B更新成C，C更新成D，最后删除E
 *
 * 有唯一的key值时，B C D E全部复用，只删除A
 *
 * 明显可以看出，当没有key值时改变元素会产生许多DOM操作，而DOM操作是非常消耗性能的，尤其是当有多层嵌套时，消耗的性能可想而知。
 */